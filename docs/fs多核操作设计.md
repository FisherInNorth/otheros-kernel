> 注意：当前为了方便，每次fs层操作都加一个全局的 `mtx_file` 锁，而不是对Dirent逐个加锁。
但是引用计数特性仍然保留。只有引用计数为1时才能删除或者改名。

1. 每当需要对Dirent的结构做增删改查时，需要对其加锁。加锁的顺序是父目录+自己。

   例如：

   * 新增：只对要新增的目录加锁
   * 删除：对要删除的文件/目录、

   注意：现在暂不考虑在删除时，仍持有对应Dirent的文件描述符的情况。但留出refcnt(引用计数)字段，未来打算是Dirent引用计数归零时才可以删除。还有linkcnt，记录指向自己的链接的数目。

2. 修改进程的cwd为字符串表示法。如果仍为当前的 `Dirent *` 表示法，那么如果这个Dirent被释放掉了或是释放掉再替换了，将引起严重的不一致错误！

3. 借鉴自xv6的inode模块：每次使用walk_path遍历路径时，需要沿途按照顶层到底层的顺序获取目的目录父目录的**引用**，使用`dget`原语（类似数据库中说的**意向锁**）。这样，在文件正常访问过程中，其顶层的所有目录均不会被删除。同样地，在释放目录时需要按逆序释放，使用 `dput`原语。

4. 文件系统管理的基本原则是：允许多个进程在加锁的情况下同时读写某个实体，但仅在引用计数归零时才能释放该实体。

5. 父目录的一致性模型：

   保证**目录内查询、删除、新增、改名**四种操作的原子性。首先对父目录加锁，然后对父目录的目录项做操作，直到引用计数改变才能释放父目录的锁。其中原子性的操作规定如下：

   * 查询操作：遍历完子Dirent列表，找到欲使用的子Dirent，将子Dirent的引用数加一
   * 删除操作：检查Dirent引用计数，若不为0，退出；若为0，则从Dirent树和磁盘中都删除该目录项
   * 新增操作：向父Dirent写入新的项目，并同步到磁盘，务必使Dirent建立完毕
   * 改名操作：暂无

   > 我们担忧的是，在使用 `dir_lookup` 查询子Dirent时，可能其引用计数为0

6. cjy的OS似乎没有实现syscall的错误码机制。即当系统调用出现错误时，返回-1，错误的具体信息存储在进程（或线程的局部存储）局部的errno变量中。现在网上针对这方面的资料极少，可能的话需要去翻阅相关代码。

7. 引用可以级联持有，但是锁一般不能在循环中级联持有（避免长期占用锁和可能的死锁）
